# SQL

[[statements|Statements в JDBC]]

## Агрегация и группировка данных

Агрегация и группировка данных позволяют сводить данные к определенным статистическим показателям. 

### **Основные агрегатные функции**

- `COUNT` - возвращает количество строк в результате запроса
- `SUM` - возвращает сумму значений в определенном столбце
- `AVG` - возвращает среднее значение по столбцу
- `MIN` - возвращает минимальное значение по столбцу
- `MAX` - возвращает максимальное значение по столбцу

### **Оператор `GROUP BY`  

Позволяет группировать данные по одному или нескольким столбцам, чтобы применять агрегатные функции к каждой группе

- Использование: когда необходимо подсчитать статистику по определенным группам данных

Пример: нужно найти среднюю зарплату по каждой должности

```sql
SELECT position, AVG(salary) as avg_salary
FROM employees
GROUP BY position
```

### **Фильтрация групп с `Having`**

`HAVING` используется для фильтрации групп по условиям, которые нельзя использовать с `WHERE`. Например, можно отобрать только те должности, средняя зарплата которых превышает определенное количество. 


```sql
SELECT position, AVG(salary) AS avg_salary
FROM employees
GROUP BY position
HAVING avg_salary > 500000
```




## Работа с несколькими таблицами

Для работы с данными, распределенными по нескольким таблицам, в SQL используются соединения (JOIN). Они позволяют извлекать данные из нескольких таблиц на основе определенных условий, объединяя записи по общим полям (чаще всего по ключевым полям). Соединения делают реляционные базы данных удобными и мощными, так как позволяют хранить данные структурировано и объединять их при необходимости.


**Основные типы соединений:**

- `INNER JOIN` - возвращает только те строки, которые имеют совпадения в обоих таблицах
	-  Используется для выбора записей, которые присутствуют в обеих таблицах по заданному условию
	-  Пример: выбор заказов и клиентов, у которых есть совпадение по `customer_id` в таблицах `orders` и `customers`
- `LEFT JOIN` - возвращает все строки из левой таблицы и только соответствующие строки из правой таблицы. Если соответствий нет, данные из правой таблицы заполняются NULL
	-  Полезен для выбора всех данных из первой таблицы и дополнительных данных из второй таблицы, даже если этих дополнительных данных нет
	-  Пример: выбор всех сотрудников и связанных с ними проектов, если такие существуют
- `RIGHT JOIN` - такой же как и LEFT JOIN, но берутся все записи из правой таблицы и только соответствующие из левой
- `FULL JOIN` - возвращает строки которые имеют совпадения в одной из таблиц или в обеих таблицах
	-  Используется для объединения всех данных из обеих таблиц, где будут присутствовать все строки, даже если совпадений нет. Если совпадение отсутствует, заполняется NULL
	-  Пример: выбор всех сотрудников и всех проектов, независимо от того, прикреплены ли сотрудники к проектам

![[sql.png]]


![[inner.png]]





## Управление данными в PostgreSQL

Управление данными - это процесс работы с данными в базе данных, который включает их создание, обновление, удаление и фильтрацию.


**Основные компоненты управления данными:**

1. Констрейнты (ограничения)
		Констрейнты - это правила, применяемые к столбцам таблиц для контроля и проверки данных. 
		 - `NOT NULL` - задает что поле не может содержать пустых значений
		 - `UNIQUE` - задает что все значения в столбце уникальны
		 - `CHECK` - задает проверочное условие для поля (Например: CHECK (age > 18))
		 - `PRIMARY KEY` - сочетает not null и unique позволяя идентифицировать запись уникальным значением
		 - `FOREIGN KEY` - ограничивает поля для обеспечения согласованности с данными с другой таблицы
2. Индексы
		Индексы — это структуры, создаваемые для ускорения поиска данных в таблице. Индексы значительно увеличивают скорость выполнения запросов, особенно для больших таблиц. Однако они занимают дополнительное место и могут замедлить операции вставки и обновления, так как индекс нужно обновлять при каждом изменении данных.
		Виды индексов в PostgreSQL:
		- **B-Tree** - подходит для равенства и диапазонов
		- **GIN и GiST** - Специализированные индексы для работы с типами данных, такими как массивы, JSON, географические данные
		- **Hash index** - подходит для операции равенства
3. **Типы данных**

	PostgreSQL поддерживает широкий спектр типов данных, что позволяет точно задать структуру таблиц и характер хранимых данных:
	
	- **Числовые типы**: INTEGER, SMALLINT, BIGINT, DECIMAL, NUMERIC, REAL, DOUBLE PRECISION.
	- **Строковые типы**: CHAR, VARCHAR, TEXT.
	- **Логические типы**: BOOLEAN — для значений true или false.
	- **Массивы**: ARRAY — позволяет хранить массив значений.
	- **JSON и JSONB**: Для хранения структурированных данных в формате JSON. JSONB — оптимизированный для поиска и фильтрации.
	- **Дата и время**: DATE, TIME, TIMESTAMP, INTERVAL — позволяют работать с датами и временем.




## Процедуры и функции


**Триггеры** - специальные процедуры, которые запускаются автоматически при наступлении определенного события


### Хранимые функции

**Хранимые функции** - это блок кода, который принимает параметры и возвращает значение. Создаются при помощи `CREATE FUNCTION`

```sql
CREATE FUNCTION calculate_bonus(salary NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
	RETURN SALARY * 0.1;
END;
$$ LANGUAGE plpgsql
```


Хранимые функции всегда возвращают значения



Пример использования функции:
```sql
SELECT name, calculate_bonus(salary) as bonus
FROM employees;
```


### Хранимые процедуры

**Хранимые процедуры** - это тоже блок кода, но они выполняют более сложные задачи в роде модификации данных и вызова других функций, они также не обязательно должны возвращать значения. Создаются с помощью команды `CREATE PROCEDURE`


```sql
CREATE PROCEDURE increase_salary(emp_id INT, increace_percentage NUMERIC)
LANGUAGE plpgsql
AS $$
BEGIN
	UPDATE employees
	SET salary = salary + (salary * increase_percentage / 100)
	WHERE id = emp_id
END;
$$;
```


Пример вызова процедуры:
```sql
CALL increase_salary(1, 5);
```




### Триггеры

Основные типы триггеров:
- **BEFORE** - выполняются перед операциями `INSERT`, `UPDATE`, `DELETE`
-  **AFTER** - выполняются после операций `INSERT`, `UPDATE`, `DELETE`
- **INSTEAD OF** — используются для представлений (`VIEW`), чтобы определить поведение при изменении данных в представлении.






## Транзакции и блокировки


**Транзакции** — это последовательности SQL-операций, которые выполняются как единое целое, и все их действия должны быть выполнены полностью или не выполнены вовсе. Это позволяет обеспечить надежность операций в базе данных, особенно при многопользовательском доступе или ошибках, возникающих во время обработки.


Для того чтобы транзакции были надежными и предсказуемыми, они должны соответствовать принципам **ACID**:

1. **Атомарность (Atomicity)**: Все операции внутри транзакции рассматриваются как одно целое. Если одна из операций не может быть выполнена, все изменения отменяются (откатываются), возвращая систему в исходное состояние. Это гарантирует, что транзакция выполнится полностью или не выполнится вообще.
    
2. **Согласованность (Consistency)**: Транзакции переводят базу данных из одного согласованного состояния в другое. Это означает, что если данные были корректны до транзакции, они останутся корректными после её завершения, даже если транзакция затрагивает несколько таблиц или операций.
    
3. **Изолированность (Isolation)**: Одновременные транзакции не должны мешать друг другу. Каждая транзакция должна быть изолирована от других, так что результаты её работы не зависят от других выполняющихся транзакций. Это предотвращает конфликты и обеспечивает корректное выполнение запросов.
    
4. **Долговечность (Durability)**: После успешного завершения транзакции все изменения данных сохраняются в базе данных, даже в случае сбоев системы. Это достигается за счет записи изменений на диск.


Работа с транзакциями в SQL осуществляется с помощью следующих команд:

- **BEGIN**: Начинает транзакцию. Все последующие SQL-операции будут выполнены в рамках этой транзакции.
- **COMMIT**: Завершает транзакцию и сохраняет все внесенные изменения. После этого данные становятся постоянными и доступны другим пользователям.
- **ROLLBACK**: Отменяет все изменения, сделанные с момента начала транзакции, и возвращает базу данных в исходное состояние, предшествующее транзакции.


Пример транзакции:
```sql
BEGIN;
UPDATE accounts SET balance = balance + 100 WHERE id = 1;
UPDATE accounts SET balance = balance - 100 WHERE id = 2;
COMMIT;
```



### Блокировки


Блокировки (Locks) в базе данных помогают управлять доступом к данным, предотвращая конфликтующие операции. Например, если два пользователя пытаются одновременно обновить одну и ту же запись, блокировка позволяет одному пользователю завершить свою операцию, прежде чем другой сможет внести изменения.



Существует несколько типов блокировок:

- **Эксклюзивная блокировка (Exclusive Lock)**: Полностью блокирует доступ к записи. Только один процесс может иметь эксклюзивную блокировку для одной записи, предотвращая другие операции записи или чтения.
    
- **Разделяемая блокировка (Shared Lock)**: Позволяет нескольким транзакциям читать данные, но не изменять их. Если у записи уже есть разделяемая блокировка, другие транзакции также могут ее прочитать, но не обновить, пока блокировка активна.


Пример блокировки с транзакцией:
```sql
BEGIN;
LOCK TABLE employees ON EXCLUSIVE MODE;
UPDATE employees SET salary = salary * 1.05 WHERE department_id = 1;
COMMIT;
```




### Индексы

Индексы в SQL — это специальные структуры данных, которые используются для ускорения поиска и извлечения данных из таблиц. Они работают аналогично указателям в книгах, позволяя быстро находить нужные строки в таблице без необходимости полного сканирования всей таблицы. Вот основные аспекты, которые нужно знать об индексах в SQL:

### 1. **Типы индексов**

- **Одностононний индекс (Single-column index)**: Индекс, созданный на одном столбце таблицы.
    
- **Составной индекс (Composite index)**: Индекс, созданный на нескольких столбцах. Он полезен, когда запросы часто используют несколько столбцов в условиях `WHERE`.
    
- **Уникальный индекс (Unique index)**: Гарантирует, что все значения в индексируемом столбце уникальны. Это также обеспечивает целостность данных.
    
- **Полнотекстовый индекс (Full-text index)**: Используется для полнотекстового поиска в текстовых данных.
    
- **Пространственный индекс (Spatial index)**: Используется для географических данных и данных, связанных с координатами.
    
- **Хэш-индекс (Hash index)**: Используется для быстрого поиска по точному совпадению, обычно в системах, которые поддерживают хэш-индексы (например, MySQL с движком MEMORY).
    

### 2. **Преимущества индексов**

- **Ускорение поиска**: Индексы позволяют быстро находить строки, соответствующие условиям запроса.
    
- **Ускорение сортировки и группировки**: Если данные уже отсортированы в индексе, то операции `ORDER BY` и `GROUP BY` выполняются быстрее.
    
- **Обеспечение уникальности**: Уникальные индексы гарантируют, что в столбце не будет дубликатов.
    

### 3. **Недостатки индексов**

- **Затраты на хранение**: Индексы занимают дополнительное место на диске.
    
- **Затраты на обновление**: При вставке, обновлении или удалении данных индексы должны быть обновлены, что может замедлить эти операции.
    
- **Не всегда полезны**: Если таблица маленькая или данные часто изменяются, индексы могут не дать значительного прироста производительности.



Индексы создаются с помощью команды `CREATE INDEX`. Например:

```sql
CREATE INDEX idx_name ON table_name (column_name);
```


Для создания составного индекса:

```sql
CREATE INDEX idx_name ON table_name (column1, column2);
```

Для создания уникального индекса:

```sql
CREATE UNIQUE INDEX idx_name ON table_name (column_name);
```

### 5. **Удаление индексов**

Индексы можно удалить с помощью команды `DROP INDEX`:

```sql
DROP INDEX idx_name ON table_name;
```

### 6. **Когда использовать индексы**

- **Частые поисковые запросы**: Если столбец часто используется в условиях `WHERE`.
    
- **Большие таблицы**: В больших таблицах индексы могут значительно ускорить поиск.
    
- **Уникальные значения**: Если столбец содержит уникальные значения, уникальный индекс может быть полезен.
    

### 7. **Когда не использовать индексы**

- **Маленькие таблицы**: В маленьких таблицах полное сканирование может быть быстрее, чем использование индекса.
    
- **Частые изменения данных**: Если данные часто изменяются, затраты на поддержание индекса могут перевесить его преимущества.
    
- **Столбцы с низкой селективностью**: Если столбец содержит много повторяющихся значений (например, булевый флаг), индекс может быть неэффективен.
    

### 8. **Планирование запросов и индексы**

- **EXPLAIN**: В большинстве СУБД можно использовать команду `EXPLAIN`, чтобы понять, как SQL-запрос будет выполняться и какие индексы будут использоваться.
    
- **Оптимизатор запросов**: СУБД использует оптимизатор запросов, который решает, использовать ли индекс для выполнения запроса.
    

### 9. **Кластеризованные и некластеризованные индексы**

- **Кластеризованный индекс (Clustered index)**: Определяет физический порядок данных в таблице. В таблице может быть только один кластеризованный индекс. Пример: первичный ключ (Primary Key).
    
- **Некластеризованный индекс (Non-clustered index)**: Создает отдельную структуру данных, которая указывает на физическое расположение данных. В таблице может быть несколько некластеризованных индексов.
    

### 10. **Примеры использования**

- **Создание индекса на столбце `email`**:
    
    ```sql
    CREATE INDEX idx_email ON users (email);
```
    
- **Создание уникального индекса на столбце `username`**:
    
    ```sql
    CREATE UNIQUE INDEX idx_username ON users (username);
```
    
- **Использование индекса в запросе**:
    
    ```sql
    SELECT * FROM users WHERE email = 'example@example.com';
```
    
    Если на столбце `email` есть индекс, этот запрос будет выполнен быстрее.
    

### 11. **Рекомендации**

- **Анализируйте запросы**: Используйте инструменты, такие как `EXPLAIN`, чтобы понять, какие индексы используются и как их можно улучшить.
    
- **Избегайте избыточных индексов**: Слишком много индексов может замедлить операции записи.
    
- **Обновляйте статистику**: В некоторых СУБД (например, SQL Server) важно обновлять статистику, чтобы оптимизатор запросов мог принимать правильные решения.
    

Индексы — это мощный инструмент для оптимизации производительности баз данных, но их нужно использовать с умом, чтобы избежать негативного влияния на производительность при операциях записи.




### CAP-теорема

CAP-теорема (теорема Брюера) — это фундаментальный принцип в распределенных системах, который описывает компромиссы между тремя ключевыми свойствами: **Согласованность (Consistency)**, **Доступность (Availability)** и **Устойчивость к разделению (Partition Tolerance)**. Теорема утверждает, что в любой распределенной системе можно гарантировать только два из этих трех свойств одновременно.

---

### 1. **Основные понятия CAP-теоремы**

#### a) **Согласованность (Consistency)**

- Все узлы в распределенной системе видят одни и те же данные в один и тот же момент времени.
    
- Если данные изменяются на одном узле, все остальные узлы должны сразу же отразить это изменение.
    
- Пример: Если вы записываете новое значение в базу данных, все последующие запросы должны возвращать это новое значение.
    

#### b) **Доступность (Availability)**

- Система всегда возвращает ответ на запрос, даже если некоторые узлы недоступны или работают некорректно.
    
- Это означает, что система продолжает работать, несмотря на сбои.
    
- Пример: Даже если один из серверов упал, пользователь все равно может читать и писать данные.
    

#### c) **Устойчивость к разделению (Partition Tolerance)**

- Система продолжает работать, даже если происходит разделение сети (network partition), то есть когда узлы теряют связь друг с другом.
    
- Это свойство особенно важно в распределенных системах, где сетевые сбои — это не исключение, а норма.
    

---

### 2. **Компромиссы CAP-теоремы**

CAP-теорема утверждает, что в распределенной системе можно одновременно гарантировать только два из трех свойств. Это означает, что при проектировании системы необходимо выбирать, какое из свойств будет принесено в жертву.

#### a) **CA-системы (Consistency + Availability)**

- Эти системы обеспечивают согласованность и доступность, но не устойчивы к разделению сети.
    
- Пример: Традиционные реляционные базы данных, такие как MySQL или PostgreSQL, в конфигурации без репликации.
    
- Проблема: Если происходит разделение сети, система может стать недоступной.
    

#### b) **CP-системы (Consistency + Partition Tolerance)**

- Эти системы обеспечивают согласованность и устойчивость к разделению, но могут стать недоступными при разделении сети.
    
- Пример: Системы, такие как Google Spanner, Apache HBase, MongoDB (в некоторых конфигурациях).
    
- Проблема: Если сеть разделена, система может отказать в обслуживании, чтобы сохранить согласованность.
    

#### c) **AP-системы (Availability + Partition Tolerance)**

- Эти системы обеспечивают доступность и устойчивость к разделению, но могут временно терять согласованность.
    
- Пример: Cassandra, DynamoDB, Riak.
    
- Проблема: При разделении сети разные узлы могут возвращать разные данные, пока сеть не восстановится.
    

---

### 3. **Примеры применения CAP-теоремы**

#### a) **Банковские системы**

- Обычно выбирают **CP**, потому что согласованность критически важна. Если сеть разделена, система может стать недоступной, чтобы избежать ошибок в данных.
    

#### b) **Социальные сети**

- Часто выбирают **AP**, потому что доступность важнее, чем мгновенная согласованность. Например, если пользователь видит временно устаревшие данные, это не критично.
    

#### c) **Торговые платформы**

- Могут выбирать **CA**, если сеть надежна, и разделение маловероятно. Однако в распределенных системах это редкость.
    

---

### 4. **Критика и уточнения CAP-теоремы**

CAP-теорема — это упрощенная модель, и на практике все сложнее:

- **Компромиссы не абсолютны**: Например, в AP-системах согласованность может быть восстановлена позже (eventual consistency).
    
- **PACELC-теорема**: Это расширение CAP-теоремы, которое учитывает, что компромиссы возникают не только при разделении сети, но и в нормальных условиях.
    
- **Реальные системы гибкие**: Многие системы позволяют настраивать баланс между CAP-свойствами в зависимости от требований.
    

---

### 5. **PACELC-теорема**

PACELC — это расширение CAP-теоремы, которое добавляет еще один уровень компромиссов:

- **При разделении сети (Partition)**: Выбор между Availability и Consistency (как в CAP).
    
- **В нормальных условиях (Else)**: Выбор между Latency (задержкой) и Consistency.
    

Пример:

- Система может выбирать между высокой согласованностью (но с большей задержкой) или низкой задержкой (но с возможной несогласованностью).
    

---

### 6. **Практические рекомендации**

- **Определите приоритеты**: Решите, что важнее для вашей системы — согласованность, доступность или устойчивость к разделению.
    
- **Используйте гибридные подходы**: Например, можно использовать AP-систему с eventual consistency для большинства операций и CP-систему для критически важных данных.
    
- **Тестируйте на разделение**: Убедитесь, что система ведет себя предсказуемо при сбоях сети.
    

---

### Итог

CAP-теорема — это важный инструмент для понимания компромиссов в распределенных системах. Она помогает разработчикам и архитекторам принимать осознанные решения при проектировании систем, учитывая требования к согласованности, доступности и устойчивости к сбоям. Однако на практике CAP-теорема — это только отправная точка, и реальные системы часто требуют более гибкого подхода.




### Вертикальное и горизонтальное масштабирование


Вертикальное и горизонтальное масштабирование — это два основных подхода к увеличению производительности и емкости системы. Они применяются как к базам данных, так и к приложениям, и каждый из них имеет свои преимущества и недостатки. Давайте разберем их подробнее.

---

## 1. **Вертикальное масштабирование (Scaling Up)**

### Что это?

Вертикальное масштабирование — это увеличение мощности существующего сервера или узла системы. Это может включать:

- Добавление более мощного процессора (CPU).
    
- Увеличение объема оперативной памяти (RAM).
    
- Увеличение объема дискового пространства (HDD/SSD).
    
- Улучшение сетевых интерфейсов.
    

### Примеры:

- Замена процессора на более мощный.
    
- Добавление оперативной памяти с 32 ГБ до 128 ГБ.
    
- Замена HDD на SSD для увеличения скорости чтения/записи.
    

### Преимущества:

- **Простота реализации**: Не требуется изменять архитектуру приложения или базы данных.
    
- **Совместимость**: Все приложения и сервисы продолжают работать без изменений.
    
- **Минимальные затраты на администрирование**: Управлять одним мощным сервером проще, чем несколькими.
    

### Недостатки:

- **Ограниченная масштабируемость**: Мощность сервера имеет физические ограничения (например, максимальное количество CPU или RAM).
    
- **Высокая стоимость**: Мощное оборудование стоит дорого.
    
- **Единая точка отказа**: Если сервер выйдет из строя, вся система станет недоступной.
    
- **Простои**: Для апгрейда оборудования может потребоваться остановка сервера.
    

### Когда использовать:

- Для небольших систем, где нагрузка растет постепенно.
    
- Когда приложение или база данных не поддерживает горизонтальное масштабирование.
    
- Для систем с критически важными данными, где простои недопустимы (например, финансовые системы).
    

---

## 2. **Горизонтальное масштабирование (Scaling Out)**

### Что это?

Горизонтальное масштабирование — это добавление новых серверов или узлов в систему для распределения нагрузки. Вместо того чтобы увеличивать мощность одного сервера, вы добавляете несколько серверов, которые работают вместе.

### Примеры:

- Добавление новых серверов в кластер баз данных.
    
- Использование балансировщиков нагрузки для распределения запросов между несколькими серверами.
    
- Шардинг (разделение данных между несколькими серверами).
    

### Преимущества:

- **Бесконечная масштабируемость**: Теоретически можно добавлять бесконечное количество серверов.
    
- **Отказоустойчивость**: Если один сервер выйдет из строя, другие продолжат работать.
    
- **Гибкость**: Можно добавлять или удалять серверы в зависимости от нагрузки.
    
- **Стоимость**: Часто дешевле добавлять несколько менее мощных серверов, чем один очень мощный.
    

### Недостатки:

- **Сложность реализации**: Требуется изменить архитектуру приложения или базы данных для поддержки распределенной системы.
    
- **Сложность администрирования**: Управление несколькими серверами требует больше усилий и инструментов.
    
- **Проблемы с согласованностью данных**: В распределенных системах сложнее обеспечивать согласованность данных (см. CAP-теорему).
    
- **Накладные расходы**: Необходимость синхронизации данных и управления кластером может увеличить задержки.
    

### Когда использовать:

- Для больших систем с высокой нагрузкой.
    
- Когда приложение или база данных поддерживает горизонтальное масштабирование (например, Cassandra, MongoDB, Kafka).
    
- Для систем, где важна отказоустойчивость и высокая доступность.
    

---

## 3. **Сравнение вертикального и горизонтального масштабирования**

|Характеристика|Вертикальное масштабирование|Горизонтальное масштабирование|
|---|---|---|
|**Сложность реализации**|Просто|Сложно|
|**Стоимость**|Высокая (дорогое оборудование)|Низкая (дешевые серверы)|
|**Масштабируемость**|Ограничена|Практически бесконечна|
|**Отказоустойчивость**|Низкая (единая точка отказа)|Высокая|
|**Администрирование**|Просто|Сложно|
|**Примеры использования**|Традиционные базы данных (MySQL)|Распределенные системы (Cassandra)|

---

## 4. **Гибридный подход**

На практике часто используется комбинация вертикального и горизонтального масштабирования. Например:

- Сначала увеличивают мощность существующих серверов (вертикальное масштабирование).
    
- Когда достигаются пределы, добавляют новые серверы (горизонтальное масштабирование).
    

Пример:

- База данных MySQL может быть вертикально масштабирована до определенного предела, после чего можно использовать шардинг или репликацию для горизонтального масштабирования.
    

---

## 5. **Примеры из реальной жизни**

### Вертикальное масштабирование:

- **Традиционные веб-сайты**: Если сайт начинает тормозить из-за увеличения трафика, можно добавить больше RAM или CPU на сервер.
    
- **Финансовые системы**: Где важна согласованность данных и минимальные простои.
    

### Горизонтальное масштабирование:

- **Социальные сети**: Такие как Facebook или Twitter, используют тысячи серверов для обработки миллиардов запросов.
    
- **Стриминговые платформы**: Например, Netflix использует горизонтальное масштабирование для обработки видео и запросов пользователей.
    

---

## 6. **Что выбрать?**

Выбор между вертикальным и горизонтальным масштабированием зависит от:

- **Требований к системе**: Если важна простота и согласованность, выбирайте вертикальное масштабирование. Если важна отказоустойчивость и масштабируемость, выбирайте горизонтальное.
    
- **Бюджета**: Вертикальное масштабирование может быть дороже в долгосрочной перспективе.
    
- **Архитектуры приложения**: Некоторые системы изначально проектируются для горизонтального масштабирования.
    

---

### Итог

- **Вертикальное масштабирование** — это быстрое и простое решение для увеличения производительности, но оно имеет ограничения.
    
- **Горизонтальное масштабирование** — это более гибкий и масштабируемый подход, но он требует сложной архитектуры и администрирования.
    

Часто лучшим решением является комбинация обоих подходов, чтобы использовать преимущества каждого из них.



### Репликация и Шардирование

Репликация и шардирование — это два ключевых подхода к масштабированию и обеспечению отказоустойчивости баз данных. Они решают разные задачи и часто используются вместе в распределенных системах. Давайте разберем их подробнее.

---

## 1. **Репликация**

### Что это?

Репликация — это процесс копирования данных с одного сервера (мастера) на один или несколько других серверов (реплик). Реплики могут использоваться для чтения данных, что позволяет распределить нагрузку и повысить отказоустойчивость.

### Типы репликации:

#### a) **Синхронная репликация**

- Данные записываются на мастер и все реплики одновременно.
    
- Гарантирует согласованность данных, но увеличивает задержку записи.
    
- Пример: PostgreSQL с синхронной репликацией.
    

#### b) **Асинхронная репликация**

- Данные сначала записываются на мастер, а затем асинхронно копируются на реплики.
    
- Уменьшает задержку записи, но может привести к временной несогласованности данных.
    
- Пример: MySQL с асинхронной репликацией.
    

#### c) **Полусинхронная репликация**

- Компромисс между синхронной и асинхронной репликацией.
    
- Данные записываются на мастер и хотя бы одну реплику перед подтверждением записи.
    
- Пример: MySQL с полусинхронной репликацией.
    

### Преимущества репликации:

- **Отказоустойчивость**: Если мастер выйдет из строя, одна из реплик может взять на себя его роль.
    
- **Распределение нагрузки**: Реплики могут использоваться для чтения, что снижает нагрузку на мастер.
    
- **Географическое распределение**: Реплики могут находиться в разных регионах, что уменьшает задержку для пользователей.
    

### Недостатки репликации:

- **Задержки репликации**: В асинхронной репликации данные на репликах могут быть устаревшими.
    
- **Сложность управления**: Необходимо следить за состоянием реплик и их синхронизацией.
    
- **Ограниченная масштабируемость записи**: Все записи по-прежнему выполняются на мастере.
    

### Примеры использования:

- **Чтение-запись разделение (Read-Write Splitting)**: Мастер обрабатывает запросы на запись, а реплики — запросы на чтение.
    
- **Резервное копирование**: Реплики могут использоваться для создания бэкапов без остановки основного сервера.
    
- **Аналитика**: Реплики могут использоваться для выполнения тяжелых аналитических запросов, чтобы не нагружать мастер.
    

---

## 2. **Шардирование (Sharding)**

### Что это?

Шардирование — это процесс разделения данных на несколько частей (шардов) и распределения их между разными серверами. Каждый шард содержит подмножество данных, и запросы обрабатываются только тем шардом, где находятся нужные данные.

### Типы шардирования:

#### a) **Горизонтальное шардирование**

- Данные разделяются по строкам. Например, пользователи с ID от 1 до 1000 хранятся на одном сервере, а с ID от 1001 до 2000 — на другом.
    
- Пример: Шардирование по диапазону значений.
    

#### b) **Вертикальное шардирование**

- Данные разделяются по столбцам. Например, одна таблица хранится на одном сервере, а другая — на другом.
    
- Пример: Разделение таблиц пользователей и заказов на разные серверы.
    

#### c) **Хэш-шардирование**

- Данные распределяются между шардами с использованием хэш-функции. Например, хэш от ID пользователя определяет, на каком шарде хранятся его данные.
    
- Пример: Cassandra, MongoDB.
    

### Преимущества шардирования:

- **Масштабируемость**: Данные и нагрузка распределяются между несколькими серверами.
    
- **Производительность**: Запросы обрабатываются быстрее, так как каждый шард содержит меньше данных.
    
- **Гибкость**: Можно добавлять новые шарды по мере роста данных.
    

### Недостатки шардирования:

- **Сложность реализации**: Требуется изменить архитектуру приложения и базы данных.
    
- **Проблемы с JOIN**: Запросы, которые требуют объединения данных из разных шардов, становятся сложными.
    
- **Балансировка нагрузки**: Неравномерное распределение данных может привести к перегрузке отдельных шардов.
    
- **Управление**: Необходимо следить за состоянием шардов и их балансировкой.
    

### Примеры использования:

- **Социальные сети**: Данные пользователей могут быть разделены по регионам или ID.
    
- **Электронная коммерция**: Заказы могут быть распределены между шардами по дате или ID заказа.
    
- **Большие данные**: Шардирование используется в системах, таких как Cassandra, MongoDB, и Elasticsearch.
    

---

## 3. **Репликация vs Шардирование**

|Характеристика|Репликация|Шардирование|
|---|---|---|
|**Цель**|Отказоустойчивость и чтение|Масштабируемость и производительность|
|**Данные**|Полные копии на всех узлах|Разделенные данные между узлами|
|**Сложность**|Проще|Сложнее|
|**Записи**|Все записи на мастере|Записи распределены между шардами|
|**Чтение**|Может быть распределено|Ограничено шардом|
|**Примеры**|MySQL, PostgreSQL|Cassandra, MongoDB|

---

## 4. **Комбинирование репликации и шардирования**

На практике репликация и шардирование часто используются вместе для достижения максимальной производительности и отказоустойчивости. Например:

- Данные разделяются на шарды, и каждый шард реплицируется на несколько серверов.
    
- Это позволяет масштабировать как запись (шардирование), так и чтение (репликация).
    

### Пример:

- **MongoDB**: Поддерживает как шардирование, так и репликацию. Данные разделяются на шарды, и каждый шард реплицируется на несколько серверов.
    
- **Cassandra**: Использует хэш-шардирование и репликацию для обеспечения отказоустойчивости.
    

---

## 5. **Когда что использовать?**

- **Репликация**:
    
    - Когда нужно обеспечить отказоустойчивость и распределить нагрузку на чтение.
        
    - Когда данные не слишком большие и могут храниться на одном сервере.
        
- **Шардирование**:
    
    - Когда данные слишком большие для одного сервера.
        
    - Когда нужно масштабировать запись и распределить нагрузку.
        
- **Комбинированный подход**:
    
    - Когда требуется и масштабируемость, и отказоустойчивость.
        

---

### Итог

- **Репликация** — это отличный способ повысить отказоустойчивость и распределить нагрузку на чтение.
    
- **Шардирование** — это мощный инструмент для масштабирования больших объемов данных и нагрузки.
    
- В реальных системах часто используется комбинация обоих подходов для достижения максимальной производительности и надежности.




### Принципы ACID


Принципы **ACID** — это набор свойств, которые гарантируют надежность и целостность транзакций в базах данных. ACID расшифровывается как **Atomicity** (Атомарность), **Consistency** (Согласованность), **Isolation** (Изолированность) и **Durability** (Долговечность). Эти принципы особенно важны в реляционных базах данных, таких как MySQL, PostgreSQL, Oracle и других, где критически важно сохранять данные в согласованном состоянии даже в условиях сбоев или параллельного выполнения операций.

Давайте разберем каждый из принципов ACID подробнее.

---

## 1. **Atomicity (Атомарность)**

### Что это?

Атомарность гарантирует, что транзакция выполняется как единое целое: либо все её операции выполняются успешно, либо ни одна из них не выполняется. Если хотя бы одна операция в транзакции завершается с ошибкой, вся транзакция откатывается (rollback), и база данных возвращается в состояние, которое было до начала транзакции.

### Пример:

Представьте, что вы переводите деньги с одного счета на другой. Транзакция состоит из двух операций:

1. Снятие денег с одного счета.
    
2. Зачисление денег на другой счет.
    

Если вторая операция завершится с ошибкой (например, счет назначения недоступен), то первая операция также должна быть отменена, чтобы деньги не "потерялись".

### Как это работает:

- Если транзакция завершается успешно, изменения фиксируются (commit).
    
- Если происходит ошибка, все изменения откатываются (rollback).
    

---

## 2. **Consistency (Согласованность)**

### Что это?

Согласованность гарантирует, что транзакция переводит базу данных из одного согласованного состояния в другое. Это означает, что данные всегда должны соответствовать определенным правилам (например, ограничениям целостности, таким как уникальность, внешние ключи, проверки и т.д.).

### Пример:

Если в базе данных есть правило, что баланс счета не может быть отрицательным, то транзакция, которая пытается снять больше денег, чем есть на счете, должна быть отклонена.

### Как это работает:

- Перед выполнением транзакции база данных находится в согласованном состоянии.
    
- После выполнения транзакции база данных также должна находиться в согласованном состоянии, даже если транзакция завершилась с ошибкой.
    

---

## 3. **Isolation (Изолированность)**

### Что это?

Изолированность гарантирует, что параллельно выполняемые транзакции не влияют друг на друга. Каждая транзакция должна выполняться так, как если бы она была единственной в системе.

### Пример:

Представьте, что два пользователя одновременно пытаются снять деньги с одного счета. Если изолированность не обеспечена, может возникнуть ситуация, когда оба пользователя снимут деньги, превысив доступный баланс.

### Уровни изолированности:

- **Read Uncommitted**: Транзакции могут видеть незафиксированные изменения других транзакций (грязное чтение).
    
- **Read Committed**: Транзакции видят только зафиксированные изменения.
    
- **Repeatable Read**: Гарантирует, что данные, прочитанные в транзакции, не изменятся до её завершения.
    
- **Serializable**: Самый строгий уровень, который полностью изолирует транзакции, как если бы они выполнялись последовательно.
    

### Проблемы изолированности:

- **Грязное чтение (Dirty Read)**: Чтение незафиксированных данных.
    
- **Неповторяющееся чтение (Non-repeatable Read)**: Данные, прочитанные в рамках одной транзакции, изменяются другой транзакцией.
    
- **Фантомное чтение (Phantom Read)**: Появление новых строк в результате выполнения другой транзакции.
    

---

## 4. **Durability (Долговечность)**

### Что это?

Долговечность гарантирует, что после успешного завершения транзакции (commit) все её изменения сохраняются в базе данных, даже в случае сбоя системы (например, отключения питания).

### Пример:

Если вы выполнили транзакцию по переводу денег, и она была успешно зафиксирована, то даже если сервер базы данных упадет сразу после этого, данные о переводе не будут потеряны.

### Как это работает:

- Изменения, сделанные в рамках транзакции, записываются в постоянное хранилище (например, на диск).
    
- Используются механизмы, такие как журналирование (WAL — Write-Ahead Logging), чтобы гарантировать сохранность данных.
    

---

## **Почему ACID важно?**

Принципы ACID обеспечивают надежность и предсказуемость работы базы данных. Они особенно важны в системах, где критически важна целостность данных, таких как:

- Банковские системы.
    
- Торговые платформы.
    
- Системы управления запасами.
    
- Любые системы, где данные должны быть точными и согласованными.
    

---

## **Ограничения ACID**

Хотя ACID обеспечивает высокую надежность, у него есть свои ограничения:

- **Производительность**: Обеспечение ACID может замедлять выполнение операций, особенно в распределенных системах.
    
- **Сложность**: Реализация ACID требует сложных механизмов, таких как блокировки, управление транзакциями и журналирование.
    
- **Масштабируемость**: В распределенных системах обеспечение ACID может быть сложным, поэтому часто используются более слабые гарантии (например, eventual consistency в NoSQL).
    

---

## **ACID vs NoSQL**

В NoSQL базах данных (таких как Cassandra, MongoDB, Redis) принципы ACID часто ослаблены или заменены на другие гарантии (например, BASE — Basically Available, Soft state, Eventually consistent). Это позволяет достичь высокой производительности и масштабируемости, но за счет снижения строгости гарантий.

---

## **Итог**

Принципы ACID — это фундаментальные свойства, которые обеспечивают надежность и целостность данных в базах данных. Они гарантируют, что транзакции выполняются атомарно, данные остаются согласованными, транзакции изолированы друг от друга, а изменения сохраняются даже в случае сбоев. Эти принципы особенно важны в реляционных базах данных, где критически важна точность и надежность данных.



### Нормализация и нормальные формы


**Нормализация баз данных** — это процесс организации данных в базе данных таким образом, чтобы минимизировать избыточность и аномалии при вставке, обновлении и удалении данных. Нормализация достигается путем разделения данных на несколько таблиц и установления связей между ними. Основная цель нормализации — улучшить целостность данных и упростить их поддержку.

Нормализация выполняется в несколько этапов, каждый из которых соответствует определенной **нормальной форме**. Давайте рассмотрим основные нормальные формы и их особенности.

---

## **Нормальные формы**

### 1. **Первая нормальная форма (1NF)**

#### Что это?

Таблица находится в первой нормальной форме, если:

- Все атрибуты (столбцы) содержат только атомарные (неделимые) значения.
    
- В таблице нет повторяющихся групп или массивов.
    

#### Пример:

**Ненормализованная таблица:**

|StudentID|Name|Courses|
|---|---|---|
|1|John Doe|Math, Physics, Chemistry|
|2|Jane Smith|History, English|

**После приведения к 1NF:**

|StudentID|Name|Course|
|---|---|---|
|1|John Doe|Math|
|1|John Doe|Physics|
|1|John Doe|Chemistry|
|2|Jane Smith|History|
|2|Jane Smith|English|

---

### 2. **Вторая нормальная форма (2NF)**

#### Что это?

Таблица находится во второй нормальной форме, если:

- Она уже находится в 1NF.
    
- Все неключевые атрибуты полностью зависят от первичного ключа (нет частичной зависимости).
    

#### Пример:

**Таблица до 2NF:**

|OrderID|ProductID|ProductName|Quantity|
|---|---|---|---|
|1|101|Laptop|2|
|1|102|Mouse|5|
|2|101|Laptop|1|

**Проблема:** `ProductName` зависит только от `ProductID`, а не от всего первичного ключа (`OrderID`, `ProductID`).

**После приведения к 2NF:**

**Таблица Orders:**

|OrderID|ProductID|Quantity|
|---|---|---|
|1|101|2|
|1|102|5|
|2|101|1|

**Таблица Products:**

|ProductID|ProductName|
|---|---|
|101|Laptop|
|102|Mouse|

---

### 3. **Третья нормальная форма (3NF)**

#### Что это?

Таблица находится в третьей нормальной форме, если:

- Она уже находится в 2NF.
    
- Все неключевые атрибуты не зависят друг от друга (нет транзитивной зависимости).
    

#### Пример:

**Таблица до 3NF:**

|StudentID|Name|Department|DepartmentHead|
|---|---|---|---|
|1|John Doe|CS|Dr. Smith|
|2|Jane Smith|Math|Dr. Johnson|

**Проблема:** `DepartmentHead` зависит от `Department`, а не напрямую от `StudentID`.

**После приведения к 3NF:**

**Таблица Students:**

|StudentID|Name|Department|
|---|---|---|
|1|John Doe|CS|
|2|Jane Smith|Math|

**Таблица Departments:**

|Department|DepartmentHead|
|---|---|
|CS|Dr. Smith|
|Math|Dr. Johnson|

---

### 4. **Нормальная форма Бойса-Кодда (BCNF)**

#### Что это?

BCNF — это усиленная версия 3NF. Таблица находится в BCNF, если:

- Она уже находится в 3NF.
    
- Для каждой функциональной зависимости X→YX→Y, XX должен быть суперключом (ключом, который уникально идентифицирует строку).
    

#### Пример:

**Таблица до BCNF:**

|StudentID|CourseID|Instructor|
|---|---|---|
|1|101|Dr. Smith|
|2|101|Dr. Smith|
|1|102|Dr. Johnson|

**Проблема:** `Instructor` зависит от `CourseID`, но `CourseID` не является суперключом.

**После приведения к BCNF:**

**Таблица StudentCourses:**

|StudentID|CourseID|
|---|---|
|1|101|
|2|101|
|1|102|

**Таблица CourseInstructors:**

|CourseID|Instructor|
|---|---|
|101|Dr. Smith|
|102|Dr. Johnson|

---

### 5. **Четвертая нормальная форма (4NF)**

#### Что это?

Таблица находится в четвертой нормальной форме, если:

- Она уже находится в BCNF.
    
- В таблице нет многозначных зависимостей.
    

#### Пример:

**Таблица до 4NF:**

|StudentID|CourseID|HobbyID|
|---|---|---|
|1|101|201|
|1|101|202|
|1|102|201|

**Проблема:** `CourseID` и `HobbyID` независимы друг от друга, но связаны через `StudentID`.

**После приведения к 4NF:**

**Таблица StudentCourses:**

|StudentID|CourseID|
|---|---|
|1|101|
|1|102|

**Таблица StudentHobbies:**

|StudentID|HobbyID|
|---|---|
|1|201|
|1|202|

---

### 6. **Пятая нормальная форма (5NF)**

#### Что это?

Таблица находится в пятой нормальной форме, если:

- Она уже находится в 4NF.
    
- В таблице нет зависимостей соединения (join dependencies), которые можно декомпозировать без потери информации.
    

#### Пример:

**Таблица до 5NF:**

|StudentID|CourseID|InstructorID|
|---|---|---|
|1|101|301|
|1|102|302|
|2|101|301|

**После приведения к 5NF:**

**Таблица StudentCourses:**

|StudentID|CourseID|
|---|---|
|1|101|
|1|102|
|2|101|

**Таблица CourseInstructors:**

|CourseID|InstructorID|
|---|---|
|101|301|
|102|302|

---

## **Преимущества нормализации**

- **Уменьшение избыточности данных**: Данные хранятся только в одном месте.
    
- **Улучшение целостности данных**: Легче поддерживать согласованность данных.
    
- **Упрощение поддержки**: Легче вносить изменения в структуру базы данных.
    
- **Снижение аномалий**: Уменьшение проблем при вставке, обновлении и удалении данных.
    

---

## **Недостатки нормализации**

- **Усложнение запросов**: Для получения данных может потребоваться выполнение множества JOIN.
    
- **Снижение производительности**: Чрезмерная нормализация может привести к увеличению времени выполнения запросов.
    

---

## **Итог**

Нормализация — это важный процесс проектирования баз данных, который помогает организовать данные эффективно и избежать аномалий. Однако важно найти баланс между нормализацией и производительностью, так как чрезмерная нормализация может усложнить запросы и снизить скорость работы базы данных.